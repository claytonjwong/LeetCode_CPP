general strategy:

start with top-down recursive solution ( DFS till base case )
results are returned back up the recursive stack

next create bottom-up DP solution ( BFS beginning at above base case(s) )
results are stored as partial solutions which build upon themselves

solutions:

link to question ( leetcode, hackerrank, etc )
pseudo code for REC/DP
actual code for REC/DP
detailed explanation with marked up code
  ( show how REC base case(s) turn into DP base cases )
  ( show overlapping sub-problems and optimal sub-structure )

general "tricks"

dp in general re-uses previous solutions in order to create current solutions
in a BFS bottom-up way.  There are 2 general iterative patterns for calculations:

create dp(size+1), return dp[size]

1) iterate from i=1 till i==size(inclusive) to check curr (i) with prev (i-1)
  OR
2) iterate from i=0 till i+1==size(inclusive) to check curr(i+1) with prev (i)
